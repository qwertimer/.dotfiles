#!/bin/bash

# Created By: Qwertimer
# Created On: "$(date)"
# Project: New System Install 

[[ "${BASH_SOURCE[0]}" != "${0}" ]] && echo "script ${BASH_SOURCE[0]} is being sourced ..." \
  && x.go && x.gum \
  && owncomp=(./install) \
  && for i in ${owncomp[@]}; do complete -C $i $i; done 
  

x.gh() {
  _have gh && echo "gh is already installed" && exit
  _is_deb && x._gh_deb
  _is_arch && x._gh_arch
}

x._gh_deb() {

  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
  && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
  && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
  && sudo apt update \
  && sudo apt install gh -y
 }
x._gh_arch() {

  sudo pacman -S github-cli
}


x.base() {
  _is_deb && sudo apt install wget curl git lynx w3m tmux vim python3 ranger htop
  _is_arch && sudo pacman -S wget curl git lynx w3m tmux vim python3 ranger htop
}

x.dev_utils() {
  
  _is_deb && sudo apt install python3
 }

x.fzf() { 
  _is_deb && sudo apt install fd-find
  _is_arch && sudo pacman -S fd
  git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf && ~/.fzf/install
}
x.pip() {
  curl https://bootstrap.pypa.io/get-pip.py | python3
}
x.docker() {
  _have docker && echo "docker is already on the system " || curl -fsSL get.docker.com | bash 
  sudo usermod -aG docker $(whoami)

}
x.lazy_docker() {
  _have lazydocker && echo "lazydocker is already installed" || \
  curl https://raw.githubusercontent.com/jesseduffield/lazydocker/master/scripts/install_update_linux.sh | bash
}

x.lazy_git() {
  _have lazygit && echo "lazygit is already installed" || \
  clone jesseduffield/lazygit
  _have go && go install || get_go && go install
}

x.ts() {
  x.tailscale
}

x.tailscale() {

  _have tailscale && echo "tailscale is already installed" && exit 
  _is_deb && curl -fsSL https://tailscale.com/install.sh | sh
  _is_arch && sudo pacman -S tailscale  \
   && sudo systemctl enable --now tailscaled && sudo tailscale up

  }

x.siab() {
  x.shell_in_a_box
}

x.shell_in_a_box() {
  _have shellinabox && echo "shellinabox is already installed" && exit
  _is_deb && sudo apt-get install shellinabox 
  _is_arch && echo "shell_in_a_box doesn't exist on arch" && x.docker_siab

  }

  x.docker_siab() {
  :
}
x.go() {
  _have go && echo "go is installed" || go_get
}

x.gum() {
  echo installing gum
  _have go && go install github.com/charmbracelet/gum@latest
}

x.skate() {
  _have go && go install github.com/charmbracelet/skate@latest
}

x.all() {
  x.sys_basics
  x.pip
  x.fzf
  x.siab
  x.ts
  x.lazy_git
  x.lazy_docker
  }

# --------------------------------- Utilities --------------------------------

_is_arch() { cat /etc/os-release | grep "ID_LIKE" | grep "arch" &>/dev/null; }
_is_deb() { cat /etc/os-release | grep "ID_LIKE" | grep "debian" &>/dev/null; }

get_go() {
  cd /tmp 
  if [[ -f go1.1* ]]; then
    echo "Go is downloaded"
  else
    wget https://go.dev/dl/go1.19.1.linux-amd64.tar.gz 
    sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf /tmp/go1.19.1.linux-amd64.tar.gz && rm /tmp/go1*
    grep -qxF 'export PATH=$PATH:/usr/local/go/bin' ~/.bashrc || echo 'export PATH=$PATH:/usr/local/go/bin' && source ~/.bashrc
  fi
  _have go && echo "Go is installed"

}

clone() {
  local repo="$1" user
  local repo="${repo#https://github.com/}"
  local repo="${repo#git@github.com:}"
  if [[ $repo =~ / ]]; then
    user="${repo%%/*}"
  else
    user="$GITUSER"
    [[ -z "$user" ]] && user="$USER"
  fi
  local name="${repo##*/}"
  local userd="$REPOS/github.com/$user"
  local path="$userd/$name"
  [[ -d "$path" ]] && cd "$path" && return
  mkdir -p "$userd"
  cd "$userd"
  echo gh repo clone "$user/$name" -- --recurse-submodule
  gh repo clone "$user/$name" -- --recurse-submodule
  cd "$name"
} && export -f clone

_have() { type "$1" &>/dev/null; }

# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=( "${line##declare -f x.}" )
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

#_config_read
#_have _initialize && _initialize "$@"

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x.$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare CMD="$1"; shift
  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$CMD" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

#if _have _alternatives; then
#  _alternatives "$@" 
#  exit $?
#fi

