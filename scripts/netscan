#!/bin/bash

RED='\033[0;31m'
GRAY='\033[0;37m'
GREEN='\033[0;32m'
NC='\033[0m'


declare -A HELP


HELP[sshScan]='Scans for ssh ports on the requested network. If no ip address is added scans the network first and then checks ssh ports. This is a slow process.'

x.sshScan() {

    net=${1:-wlp5s0}
    printf "$net"
    broadcast=$(ip addr show $net| awk '$1 == "inet" &&  $4 !~ /^host/ { print $4"/24" }' | uniq)

    RED='\033[0;31m'
    GRAY='\033[0;37m'
    GREEN='\033[0;32m'
    NC='\033[0m'

    #clear
    printf "${GRAY}Executing nmap on network: ${RED}\n$broadcast\n"
    candidates=$(
    for brdip in ${broadcast}; do 
      nmap -sP $brdip | awk '$2 == "scan" { print $5 }'
    done)
    printf "${GRAY}\nFound the following devices: ${GREEN}\n$candidates\n$NC"

    #Auto port scan.
    for ip in ${candidates}; do
      printf "${GRAY}\nProbing $ip...\n${NC}"
      nmap -sV -p- "$ip"
    done

    echo "Nothing found"
}


HELP[showNet]='Shows all devices on the network, User provides input to choose which network to scan, based on a network check'

x.showNet() {


  printf "%b\nNetwork protocols available to scan%b\n" "${GRAY}" "${RED}"
  ifconfig -a | grep UP | grep -E "e(th|n)|wl" | sed 's/:.*//;/^$/d'
  printf "$NC"
  read -p "Which network would you like to scan: " net
  declare -a var
  while IFS='(' read -a Line; do
    var+=( "${Line[1]%%)*}" )
  done < <(arp -a | grep $net | grep "$1");
  printf '%b\nFound these IP addresses:\n' "${GRAY}" 
  for item in "${var[@]}"; do
    printf '%b%s\n' "${GREEN}" "$item"
  done
  printf "$NC"
  #for i in "${var[@]}"; do
  #  printf "Scanning %b%s\n%b" "${RED}" "$i" "$NC"
    #printf "Checking OS\n"
    #sudo nmap -O "$i"
    #printf "Checking hostname\n"
        #nmap -sL "$i"
  #  nmap -sV -p- "$i"
  #done

}
HELP[shareNet]=' Gets the host network connection and parses it to the subnetwork. The default configuration is to send the wifi to the ethernet. The defaults are configured but the user may input WLAN and LAN.
-WLAN is $1
-LAN is $2
'
x.shareNet() {
    WLAN="${1:-wlp5s0}"
    LAN="${2:-enp6s0}"

    echo "Starting DHCP server for $LAN, sharing connection $WLAN..."
    sudo systemctl start dnsmasq.service
    echo "Adding allow rules to firewall..."
    sudo ufw route allow in on $LAN out on $WLAN comment "dhcp gateway routing"
    echo "Adding IP routes..."
    echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward > /dev/null
    sudo iptables -t nat -A POSTROUTING -o $WLAN -j MASQUERADE
    sudo iptables -A FORWARD -i $LAN -o $WLAN -j ACCEPT
    sudo iptables -A FORWARD -i $WLAN -o $LAN -m state --state RELATED,ESTABLISHED -j ACCEPT
    echo "Tailing DHCP leases file:"
    sleep 10
    tail /var/lib/misc/dnsmasq.leases

    #while read -ar LEASES; do
    #  nmap -sV -p- "${LEASES[@]}"
    #done < /var/lib/misc/dnsmasq.leases
    #while read -r; do printf '%s\n' "$REPLY"; done < /var/lib/misc/dnsmasq.leases
:
}





HELP[usage]='Displays a summary of usage.'
x.usage() {
  local -a cmds
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:1} =~ _ ]] && continue
    cmds+=("$c")
  done
  local IFS='|'
  printf "usage: %s (%s)\n" "$EXE" "${cmds[*]}"
}

# --------------------------------- utilities --------------------------------
_have(){ type "$1" &>/dev/null; }


_filter(){
  [[ -n "$1" ]] && return 1
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

_buffer() {
  [[ -n "$1" ]] && return 1
  "${FUNCNAME[1]}" "$(</dev/stdin)"
}


# --------------------- completion and delegation --------------------
#      `complete -C foo foo` > `source <(foo bloated_completion)`
while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=( "${line##declare -f x.}" )
done < <(declare -F)

mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "x.$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare CMD="$1"; shift
  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$CMD" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

if _have _alternatives; then
  _alternatives "$@" 
  exit $?
fi
